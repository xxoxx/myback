---
layout: post
title: tornado配置解析
date: 2016-09-13 10:50
categories: [web框架]
tags: [tornado,options,define,配置解析]
---


　　tornado的options模块是一个命令行解析模块，此模块不仅可以从命令行解析传递的选项，也能从配置文件解析。以下边的事例来进行说明。
<!--more-->

```python
from tornado.options import options, define
from tornado.web import Application, RequestHandler
from tornado.ioloop import IOLoop


define("port", default=8000, type=int, help="listen port")


class MainHandler(RequestHandler):
    def get(self, *args, **kwargs):
        self.write('hello')


if __name__ == '__main__':
    app = Application(
        [
            (r'/', MainHandler)
        ], debug=True
    )
    app.listen(port=options.port, address='0.0.0.0')
    IOLoop.current().start()
```

要使用tornado的配置解析功能需要从`options`模块中引入`options`和`define`两个对象，`define`函数定义全局命名空间的选项，比如上边定义的`port`选项，后边就可以使用`tornado.options.options.port`来调用，运行上边的程序可以发现，程序监听在了`8000`端口，如下：

```sh
neal@neal-System-Product-Name:~$ ss -tnlp | grep 8000
LISTEN     0      128          *:8000                     *:*                   users:(("python",pid=18033,fd=6))
neal@neal-System-Product-Name:~$ 
```

如果要让程序可以接受命令行传递的参数，那可以这样来改造程序，如下：

```python
from tornado.options import options, define
from tornado.web import Application, RequestHandler
from tornado.ioloop import IOLoop


define("port", default=8000, type=int, help="listen port")


class MainHandler(RequestHandler):
    def get(self, *args, **kwargs):
        self.write('hello')


if __name__ == '__main__':
    options.parse_command_line()
    app = Application(
        [
            (r'/', MainHandler)
        ], debug=True
    )
    app.listen(port=options.port, address='0.0.0.0')
    IOLoop.current().start()
```

上边加入了`options.parse_command_line()`这一行代码，表示解析命令行传递的参数，参数使用_--name=value_的格式传递，试着运行上边的代码，如下：

```sh
(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ python options_test.py --port=8080
(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ ss -tnlp | grep python)
LISTEN     0      128          *:8080                     *:*                   users:(("python",pid=20086,fd=6))
```

程序监听在了`8080`端口，是从命令行传递过来的，所以可以知道，当在`define`函数中定义的选项，当在调用`define`的选项之前又定义了`options.parse_command_line()`从命令行捕获选项，那程序运行时传递了相应的选项，那程序就使用这个在命令行传递选项的值，如果程序运行时没有传递选项，那就采用define中定义的默认值。



options模块不仅可以从define和命令行获取选项的值，还可以读取指定一个配置文件，从配置文件读取选项和值，请看下边代码：

```python
from tornado.options import options, define
from tornado.web import Application, RequestHandler
from tornado.ioloop import IOLoop


define("port", default=8000, type=int, help="listen port")


class MainHandler(RequestHandler):
    def get(self, *args, **kwargs):
        self.write('hello')


if __name__ == '__main__':
    options.parse_config_file('./application.conf')
    app = Application(
        [
            (r'/', MainHandler)
        ], debug=True
    )
    app.listen(port=options.port, address='0.0.0.0')
    IOLoop.current().start()
```

applications.conf格式如下：

```sh
(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ cat application.conf 
port = 8080
```

程序运行后可发现程序监听在`8080`端口，即是从配置文件里读取的配置信息，如下：

```sh
(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ ss -tnlp | grep python
LISTEN     0      128          *:8080                     *:*                   users:(("python",pid=22126,fd=6))
```

如果同时定义了从配置文件读取和从命令行读取，那生效的是哪个呢？做如下测试：

```python
from tornado.options import options, define
from tornado.web import Application, RequestHandler
from tornado.ioloop import IOLoop


define("port", default=8000, type=int, help="listen port")


class MainHandler(RequestHandler):
    def get(self, *args, **kwargs):
        self.write('hello')


if __name__ == '__main__':
    options.parse_config_file('./application.conf')
    app = Application(
        [
            (r'/', MainHandler)
        ], debug=True
    )
    options.parse_command_line()
    app.listen(port=options.port, address='0.0.0.0')
    IOLoop.current().start()
```

程序如下运行后查看监听在哪个端口：

```sh
(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ python options_test.py --port=8005
(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ ss -tnlp | grep python
LISTEN     0      128          *:8005                     *:*                   users:(("python",pid=23810,fd=6))
```

程序监听在`8005`端口，如果不在命令行传递参数，那程序会监听在哪个端口？如下：

```sh
(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ python options_test.py
(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ ss -tnlp | grep python)
LISTEN     0      128          *:8080                     *:*                   users:(("python",pid=24093,fd=6))
```

程序监听在了`8080`这个配置在配置文件中的端口。如果把`options.parse_command_line()`放在`app.listen(port=options.port, address='0.0.0.0')`之后呢？如下：

```python
from tornado.options import options, define
from tornado.web import Application, RequestHandler
from tornado.ioloop import IOLoop


define("port", default=8000, type=int, help="listen port")


class MainHandler(RequestHandler):
    def get(self, *args, **kwargs):
        self.write('hello')


if __name__ == '__main__':
    options.parse_config_file('./application.conf')
    app = Application(
        [
            (r'/', MainHandler)
        ], debug=True
    )
    app.listen(port=options.port, address='0.0.0.0')
    options.parse_command_line()
    IOLoop.current().start()
```

再运行程序试试，如下：

```sh
gscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ python options_test.py --port=8005
(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ ss -tnlp | grep python
LISTEN     0      128          *:8080                     *:*                   users:(("python",pid=24267,fd=6))
```

程序监听在`8080`这个定义在配置文件中的端口，如果不传递命令行参数呢？

```sh
gscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ python options_test.py
(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ ss -tnlp | grep python
LISTEN     0      128          *:8080                     *:*                   users:(("python",pid=24393,fd=6))
```

同样监听在`8080`端口，依然是配置文件中定义的参数，如果把配置文件中的信息清除呢？

```sh
(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ echo "" > application.conf 
(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ python options_test.py --port=8005
(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ ss -tnlp | grep python
LISTEN     0      128          *:8000                     *:*                   users:(("python",pid=25126,fd=6))

(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ python options_test.py
(logscan-api) neal@neal-System-Product-Name:~/private/sync/temp/logscan-api/test_scripts$ ss -tnlp | grep python
LISTEN     0      128          *:8000                     *:*                   users:(("python",pid=25384,fd=6))
```

当把配置文件中的配置项去除后不管命令行是否传递参数，程序都监听在了`8000`端口，即是define中的默认值。













